---
title: "여러가지 공부"
date: 2020-05-12 23:20:00 -0400
category: study
---

## 네트워크

RESTful
Representational State Transfer  
URI를 통해 Resource를 명시, Stateless Protocol  
HTTP 매소드를 통해 해당 자원의 CRUD Operation을 적용  
Create(POST), Read(GET), Update(PUT), Delete(DELETE), HEAD(HEAD)  

장점
- HTTP프로토콜 인프라 사용으로 REST API를 위한 별도 인프라 불필요
- 서버와 클라 역할 분리

단점
- 매소드 제한적
- 표준 존재 x

서버에 Client의 context(세션, 쿠키, 클라이언트의 다양한 상태 정보)를 저장 하지 않음, 즉 서버는 context정보를 신경쓰지 않아도 됌  

캐시 처리 가능  
계층화 - 구조적 유연성  

[NHN 정리 글](https://meetup.toast.com/posts/92)  
[TCP/IP 정리 글](https://d2.naver.com/helloworld/47667)  
[네트워크 정리](https://asfirstalways.tistory.com/327)  
  
HTTP status  

|-----|-------------------------------|
| 200 | 정상|
| 201 | 리소스 생성 요청 성공|
| 400 | 요청 부적절 |
| 401 | 인증 안된 요청 |
| 403 | 리소스 존재, 하지만 응답하고 싶지 않음 |
| 405 | 사용 불가한 매소드 |
| 301 | URI이 변경 됐음 |
| 500 | 서버 문제 발생 |

HTTP & HTTPS  
HTTP는 평문 통신, 통신 상대 확인 x, 완전성x  
HTTP에 SSL이나 TLS를 조합해서 암호화 -> HTTPS  
SSL은 상대를 확인 하는 증명서, SSL로 상대를 확인  
상대 확인 안하면, 원래 보낸 곳인지 모름, 어디서 보냈는지 모름, 의미없는거 수신 -> DoS  
정보의 정확성 = 안전성 -> SSL 사용해서 암호화  
원래 HTTP는 TCP와 직접 통신  
HTTPS는 HTTP는 SSL, SSL은 TCP와 통신  

HTTP  
GET  
- HTTP Request Message에 Header URL에 ? 하고 정보가 보이고 데이터 크기가 제한적
- 캐싱 가능

POST - HTTP Message Body에 데이터 담김  

  
## 스프링

트랜잭션 처리  
어노네티션 @Transactional로 선언처리 = 선언적 트랜잭션  
어노테이션을 달면 트랜잭션 기능이 적용된 프록시 객체 생성  
이 프록시 객체가 PlatformTransactionManager를 사용하여 트랜잭션 시작하고 커밋 및 롤백  

트랜잭션 속성  

| 격리 수준 | 레벨 | 특징 | 비고 |
|------------------|---------|-------------------------------|----------------|
| READ_UNCOMMITTED | level 0 | 커밋되지 않은 처리중인 데이터 읽기 허용 | Dirty Read 발생|
| READ_COMMITTED | level 1 | 커밋된 데이터만 읽기 허용 | Dirty Read 방지 |
| REPEATABLE_READ | level 2 | 트랜잭션이 완료될때 까지 shared lock, 데이터 수정 불가능 | Non-Repeatable Read 방지 |
| SERIALIZABLE | level 3 | shared lock, 수정 및 입력 불가능 | Phathom Read 방지 |

-> 레벨이 올라갈 수록 성능 저하 우려  
  
| 전파 옵션 | 특징 |
|---------------|-------------------------------------|
| REQUIRED | 디폴트, 부모 트랜잭션내에서 실행, 없으면 신규 생성|
| SUPPORTS | 이미 있으면 참여, 아니면 트랜잭션 없이 진행 |
| REQUIRES_NEW | 부모 무시, 새로운 트랜잭션 생성 |
| MANDATORY | 있으면 참여, 없으면 예외 발생, 독립적으로 진행되면 안될때 |
| REQUIRED_NEW | 항상 새로운거 생성, 진행중인건 보류 상태로 |
| NOT_SUPPORTED | 트랜잭션 사용 안함, 진행중이면 보류 상태로 |
| NEVER | 트랙재션 사용 안하도록 강제, 진행중인거 있음 예외 발생 |
| NESTED | 진행중인 트랜잭션 있으면 중첩, 트랜잭션 안에 트랜잭션, 자식이 부모에게 영향을 못 줌|

## 자료구조

Set  
데이터의 집합, List와 달리 중복을 허용하지 않음  
List와 같이 Collection implementation  

| 종류 | 특징 |
|---------------|------------------------------|
| HashSet | 순서 보장 없음 |
| TreeSet | 오름차순 데이터 저장 |
| LinkedHashSet | 들어간 순서대로 저장 |
  
Map
키와 value로 이뤄진 데이터의 집합, 키의 중복 x  
얘는 Map 인터페이스, Collection implementation x  
고유의 인덱스로 key 검색, Hash Function  

| 종류 | 특징 |
|--------------|------------------------------|
| HashMap | 순서 보장 x, 키와 값으로 null 허용|
| HashTable | 동기화 지원, 키와 값으로 null 허용 x|
| TreeMap | 이진 검색 트리, 저장시 오름차순 저장, 저장 오래걸림|
| LinkedHashMap | 들어간 순서대로 |

## java

syncronized  
멀티 스레드 환경에서 공유되는 data를 쓰레드간 동기화를 시키는것  

String, StringBuilder, StringBuffer  
String  
String은 불변 = 한번 생성되면 메모리 공간이 변하지 않음  
+연산자는 연결된 문자열을 새로운 객체에 연결하고 새로운 객체를 참조하도록, 기존 객체는 가비지 컬랙션  
연산이 많으면 성능이 떨어지지만, Thread-safe  

StringBuffer & StringBuilder  
연산으로 기존 객체의 공간이 부족하다면, 버퍼크기를 늘려 유연하게 동작  
StringBuffer = Synchronized Keyword 존재, 멀티스레드에 적합  
StringBuilder = 동기화 처리 안함, 성능은 더좋음  

메모리 Stack & Heap  
Stack  
Heap에 생선된 Object 데이터의 참조값 할당, 원시 타입은 값과 함께 할당  
각 스레드는 자신만의 Stack  

Heap  
긴 생명주기의 데이터 저장  
스레드가 몇개든, 하나의 Heap만 존재

가비지 컬랙션  
자바는 OS 메모리 영역에 직접적 접근 x, JVM을 통해 간접적 접근  
JVM이 오브젝트가 필요해지지 않는 시점에서 알아서 메모리 확보  

Heap영역의 오브젝트 중 Stack에서 도달 불가능한 오브젝트들은 가비지 컬랙션 대상  
예를 들어 String이 + 되면서 새로운 걸 참조 할 때 이전 Strign은 버려짐 = Unreachable  
Garbage Collector가 스택의 변수를 스캔하면서 어떤걸 래퍼랜스 하는지 확인 = Mark
Mark 되어있지 않는 오브잭트 제거 = Sweep  
  
## 디자인 패턴
싱글톤  
인스턴스를 하나만 만들어 사용하는 패턴  
인스턴스 생성에 재약을 걸어둬야 함  

- new를 못하게 생성자를 private
- 단일 객체를 반환하게 getInstance 여기에 synchronized
- 혹은 volatile로 객체를 클래스가 로딩될떄 미리 생성하고 반환
- volatile -> 멀티스레드 환경에선 메인 메모리에서 읽은걸 캐쉬에 저장, 캐쉬를 참조 못하게 하는걸 volatile
