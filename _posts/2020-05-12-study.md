---
title: "내가 보려고 쓴 공부 정리"
date: 2020-05-12 22:45:00 +0900
category: study
lastmod : 2021-01-31 22:45:00 +0900
sitemap :
  changefreq : weekly
  priority : 1.0
---

<br>

---

## 네트워크

- [RESTful API 정리](https://kingjakeu.github.io/study/2020/08/08/rest/)
- [HTTP와 HTTPS 차이 + 쿠키와 세션](https://kingjakeu.github.io/study/2020/08/11/HTTP-HTTPS/)
- [POST와 PUT의 차이](https://kingjakeu.github.io/study/2020/07/15/http-post-put/)
- [OSI & TCP/IP](https://kingjakeu.github.io/study/2020/08/11/OSI-TCP-IP/)
- [웹 브라우저 동작](https://kingjakeu.github.io/study/2021/01/10/browser-url-typed/)

### 그 외

- Nagle Algorithm  
조금씩 여러번 대신 한번에 많이 보내기, TCP 기본값 on  
데이터를 보내고 ACK를 받을 때까지 출력 버퍼에 저장 했다가 ACK를 받으면 한번에 보냄  

- DNS round robin 방식

- TCP 와 UDP 의 차이점

---

## Java

- [JVM 구동 원리](https://kingjakeu.github.io/java/2020/08/11/java-excute/)
- [가비지 컬랙터](https://kingjakeu.github.io/java/2020/08/11/garbage-collection/)
- [클래스 로더](https://kingjakeu.github.io/java/2020/08/10/class-loader/)
- [자바 인터페이스](https://kingjakeu.github.io/java/2021/01/05/interface-java/)
- [자바 String](https://kingjakeu.github.io/java/2020/08/12/java-string/)

### 그 외

- Anonymous Class  
마치 함수 형처럼 이미 있는 클래스를 상속하거나 인터페이스를 구현해서 일회용으로 쓰는거  
익명 객체에 새롭게 정의 된 필드는 익명객체의 내부에서만 가능  

- Checked Exception & Unchecked Exception  
Checked = 예외처리 필수, 롤백 안됌, IOException, SQLException  
unchecked = 예외처리 안해도 됌, 롤백, null Pointer exception  

- 제네릭  
클래스를 정의 할때는 데이터 타입을 확정하지 않고, 인스턴스를 생성할때 지정하는 기능  
쓰는 이유, 컴파일 단계에서 오류 검출, 중복 제거와 타입 안정성  
extends로 올수 있는 데이터 타입 제한 가능

- Collection
- Annotation
- Access Modifier
- Wrapper class
- Multi-Thread

---

## 스프링

- 스프링 컨테이너
  스프링 프레임워크의 코어. 컨테이너는 객체를 만들고, 연결하고, 구성하고, 생성되고 없어질 때까지 라이프 사이클을 관리함.

- Spring BeanFactory Container
  기본 DI 제공. 서드 파티 프레임워크들이 스프링에 적용될 수 있도록, backward compatibility 제공

- Spring ApplicationContext Container
  프로퍼티 파일에 textual message를 엔터프라이즈 기능을 추가하고, 어플리케이션 이벤트를 이벤트 리스너에 제공.

- JoinPoint
- Bean Life-Cycle [참고](https://www.geeksforgeeks.org/bean-life-cycle-in-java-spring/)

- @Transactional
  class에 선언하면, public 매소드에만 적용, private or protected는 적용되지 않음
  method에 선언하면, 해당 메소드에만 적용
  같은 클래스안에서 호출하는 메소드는 적용 x, because of spring proxy pattern

---

## 자료구조

- [Map & Set 비교 + 그래프](https://kingjakeu.github.io/study/2020/08/12/set-map/)

- Array와 LinkedList  
  Array  
  논리적 & 물리적 저장 순서가 일치하는 연속적인 데이터의 집합  
  찾고자 하는 원소의 인덱스 값을 안다면 O(1)로 접근 가능  
  하지만 삽입과 삭제에서 shift로 인한 worse case O(n)  

  LinkedList
  노드의 연결로 나타낸 데이터의 집합, 논리적 != 물리적 저장 순서  
  삽입과 삭제가 O(1)만에 해결 할 수 있지만  
  search과정에서 O(n)이 필요  

- Hash Table & HashFunction  
  Open Address & Separate Chaining  

- Java HashFunction  
  hashCode에 M(hash bucket) 크기 % 계산  
  M은 소수 일때 성능 최고, 부족해지면 M*2, LoadFactor 0.75 일때까지  
  Java 8이전에는 보조 해시 함수로 복잡, 하지만 8이후는 커지면 레드블랙트리로 바꾸기에 간단하게 상위 16비트 값 XOR연산  
  String의 경우 Horner's Method로 해쉬에 31을 재귀로 곱한 값에 각 문자열 더하기

- Tree
  Binary Tree, Full Binary Tree, Complete Binary Tree, BST (Binary Search Tree), Binary Heap, Red-Black Tree

- Graph
  Graph 탐색, Minimum Spanning Tree, Kruskal algorithm, Prim algorithm

---

## 디자인 패턴

- [디자인 패턴 정리](https://kingjakeu.github.io/study/2020/08/11/design-pattern/)

---

## 운영체제

---

## 데이터 베이스

- [트랜잭션 특징, 격리, 전파](https://kingjakeu.github.io/study/2020/08/06/transactions/)

디비 커넥션 풀  
WAS의 디비 접근시 가장 많은 코스트를 발생하는 곳은 첫 연결을 맺는 것  
그렇기 때문에 미리 커넥션을 맺어 놓고 Pool에 저장,  
HTTP 요청에 따라 필요할 떄 pool에서 connection 객체를 쓰고 반환  
WAS의 스레드 수는 커낵션 풀의 갯수보다 여유롭게 설정  

Left join  
outer join으로 조건 항목이 있으면 묶고 아니면 내비둠  

정규화
한 릴레이션에서 여러 엔티티의 애트리뷰트들을 혼합하게 되면 중복 저장에 갱신 이상이 생길수 있다  
중복을 최소화하기 위해 데이터를 구조화 하는 작업  
1 정규형 - 모든 애트리뷰트가 도메인에 속하는 하나의 값, 복합 애트류뷰트 x  
2 정규형 - 모든 비주요 애트리뷰트들이 주요 애트리뷰트에 오나전 함수 종속적  
3 정규형 - 기본키에 대해 이행적으로 종속되지 않는 관계  
문제점 = 릴레이션의 분해로 JOIN연산이 많아짐  

NoSQL  
관계형 데이터 모델 지양, 스키마없이 사용하거나 느슨한 스키마, 저장 조회에 특화  
종류  
Key-value Model, Document Model(Mongo DB), Column Model  

- mysql json 입력
- table maintenance statements sql

- MySQL Strict Mode
  컬럼 크기보다 큰 스트링 테이터를 입력하면, 디비는 사이즈보다 큰 데이터를 truncate 하고, unsigned 에 negative를 넣으면 0으로 만듬. 여기에 Strict Mode로 전환 하게 되면, 컬럼에 맞지 않은 데이터는 오류로 처리됌

---

## 그 외

DI  
한 객체가 다른 객체를 참조하고 있다면 해당 객체는 다른 객체에 의존성을 가짐  
원래는 개발자가 인스턴스를 생성하면서 해당 의존성 주입 했지만,  
IoC(Inversion of Control)로 프레임워크가 의존성을 주입함  
Bean Container가 Bean을 생성하고 주입 함  

의존성 주입 세가지  
생성자, 매소드(세터), 필드  

CAP 이론  
Consistency - 모든 노드가 같은 순간에 같은 데이터를 볼수 있다  
Availability - 모든 요청이 성공 또는 실패 결과를 반환 할수 있다  
Partition tolerance - 메시지 전달이 실패하거나 일부가 망가져도 시스템이 계속 동작할 수 있다  
세 가지를 모두 만족할 수 없다  

클라우드 환경, 마이크로서비스 구조  
이전에 모노폴릭 구조에서는 하나의 서버에 하나의 서비스가 올라가고   
여기에 서비스를 쪼개서 올린다면 낭비되는 자원 + 추가 비용이 발생  
하지만 클라우드 환경에선 그런게 없음
