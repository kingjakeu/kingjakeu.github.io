---
title: "여러가지 공부"
date: 2020-05-12 23:20:00 -0400
category: study
---

## 네트워크

RESTful
Representational State Transfer  
URI를 통해 Resource를 명시, Stateless Protocol  
HTTP 매소드를 통해 해당 자원의 CRUD Operation을 적용  
Create(POST), Read(GET), Update(PUT), Delete(DELETE), HEAD(HEAD)  

장점
- HTTP프로토콜 인프라 사용으로 REST API를 위한 별도 인프라 불필요
- 서버와 클라 역할 분리

단점
- 매소드 제한적
- 표준 존재 x

서버에 Client의 context(세션, 쿠키, 클라이언트의 다양한 상태 정보)를 저장 하지 않음, 즉 서버는 context정보를 신경쓰지 않아도 됌  

쿠키와 세션의 차이점  

| |쿠키|세션|
|----------|------------------|-----------------|
|저장위치| 클라이언트 | 서버 |
|보안| 보안 취약 | 세션ID만 저장, 쿠키보다 안정|
|라이프사이클| 브라우저를 종료해도 있음 | 브라우저 종료시 삭제|
|속도| 클라에 저장, 서버요청시 빠름| 서버라 클라보단 느림|
  

캐시 처리 가능  
계층화 - 구조적 유연성  

[NHN 정리 글](https://meetup.toast.com/posts/92)  
[TCP/IP 정리 글](https://d2.naver.com/helloworld/47667)  
[네트워크 정리](https://asfirstalways.tistory.com/327)  
  
HTTP status  

|-----|-------------------------------|
| 200 | 정상|
| 201 | 리소스 생성 요청 성공|
| 400 | 요청 부적절 |
| 401 | 인증 안된 요청 |
| 403 | 리소스 존재, 하지만 응답하고 싶지 않음 |
| 405 | 사용 불가한 매소드 |
| 301 | URI이 변경 됐음 |
| 500 | 서버 문제 발생 |

HTTP & HTTPS  
HTTP는 평문 통신, 통신 상대 확인 x, 완전성x  
HTTP에 SSL이나 TLS를 조합해서 암호화 -> HTTPS  
SSL은 상대를 확인 하는 증명서, SSL로 상대를 확인  
상대 확인 안하면, 원래 보낸 곳인지 모름, 어디서 보냈는지 모름, 의미없는거 수신 -> DoS  
정보의 정확성 = 안전성 -> SSL 사용해서 암호화  
원래 HTTP는 TCP와 직접 통신  
HTTPS는 HTTP는 SSL, SSL은 TCP와 통신  

HTTP  
GET  
- HTTP Request Message에 Header URL에 ? 하고 정보가 보이고 데이터 크기가 제한적
- 캐싱 가능

POST - HTTP Message Body에 데이터 담김  

  
## 스프링

트랜잭션 처리  
어노네티션 @Transactional로 선언처리 = 선언적 트랜잭션  
어노테이션을 달면 트랜잭션 기능이 적용된 프록시 객체 생성  
이 프록시 객체가 PlatformTransactionManager를 사용하여 트랜잭션 시작하고 커밋 및 롤백  

트랜잭션 속성  

| 격리 수준 | 레벨 | 특징 | 비고 |
|------------------|---------|-------------------------------|----------------|
| READ_UNCOMMITTED | level 0 | 커밋되지 않은 처리중인 데이터 읽기 허용 | Dirty Read 발생|
| READ_COMMITTED | level 1 | 커밋된 데이터만 읽기 허용 | Dirty Read 방지 |
| REPEATABLE_READ | level 2 | 트랜잭션이 완료될때 까지 shared lock, 데이터 수정 불가능 | Non-Repeatable Read 방지 |
| SERIALIZABLE | level 3 | shared lock, 수정 및 입력 불가능 | Phathom Read 방지 |

-> 레벨이 올라갈 수록 성능 저하 우려  
  
| 전파 옵션 | 특징 |
|---------------|-------------------------------------|
| REQUIRED | 디폴트, 부모 트랜잭션내에서 실행, 없으면 신규 생성|
| SUPPORTS | 이미 있으면 참여, 아니면 트랜잭션 없이 진행 |
| REQUIRES_NEW | 부모 무시, 새로운 트랜잭션 생성 |
| MANDATORY | 있으면 참여, 없으면 예외 발생, 독립적으로 진행되면 안될때 |
| REQUIRED_NEW | 항상 새로운거 생성, 진행중인건 보류 상태로 |
| NOT_SUPPORTED | 트랜잭션 사용 안함, 진행중이면 보류 상태로 |
| NEVER | 트랙재션 사용 안하도록 강제, 진행중인거 있음 예외 발생 |
| NESTED | 진행중인 트랜잭션 있으면 중첩, 트랜잭션 안에 트랜잭션, 자식이 부모에게 영향을 못 줌|

## 자료구조

Set  
데이터의 집합, List와 달리 중복을 허용하지 않음  
List와 같이 Collection implementation  

| 종류 | 특징 |
|---------------|------------------------------|
| HashSet | 순서 보장 없음 |
| TreeSet | 오름차순 데이터 저장 |
| LinkedHashSet | 들어간 순서대로 저장 |
  
Map
키와 value로 이뤄진 데이터의 집합, 키의 중복 x  
얘는 Map 인터페이스, Collection implementation x  
고유의 인덱스로 key 검색, Hash Function  

| 종류 | 특징 |
|--------------|------------------------------|
| HashMap | 순서 보장 x, 키와 값으로 null 허용|
| HashTable | 동기화 지원, 키와 값으로 null 허용 x|
| TreeMap | 이진 검색 트리, 저장시 오름차순 저장, 저장 오래걸림|
| LinkedHashMap | 들어간 순서대로 |

## java

syncronized  
멀티 스레드 환경에서 공유되는 data를 쓰레드간 동기화를 시키는것  

String, StringBuilder, StringBuffer  
String  
String은 불변 = 한번 생성되면 메모리 공간이 변하지 않음  
+연산자는 연결된 문자열을 새로운 객체에 연결하고 새로운 객체를 참조하도록, 기존 객체는 가비지 컬랙션  
연산이 많으면 성능이 떨어지지만, Thread-safe  

StringBuffer & StringBuilder  
연산으로 기존 객체의 공간이 부족하다면, 버퍼크기를 늘려 유연하게 동작  
StringBuffer = Synchronized Keyword 존재, 멀티스레드에 적합  
StringBuilder = 동기화 처리 안함, 성능은 더좋음  

메모리 Stack & Heap  
Stack  
Heap에 생선된 Object 데이터의 참조값 할당, 원시 타입은 값과 함께 할당  
각 스레드는 자신만의 Stack  

Heap  
긴 생명주기의 데이터 저장  
스레드가 몇개든, 하나의 Heap만 존재

Native Memory는 Off-Heap영역 = 시스템의 기본 메모리  
Java 8 부터는 Permgen 메모리가 Meataspace로 바뀜 Native Memory에 할당

**가비지 컬랙션**
자바는 OS 메모리 영역에 직접적 접근 x, JVM을 통해 간접적 접근  
JVM이 오브젝트가 필요해지지 않는 시점에서 알아서 메모리 확보  

Heap영역의 오브젝트 중 Stack에서 도달 불가능한 오브젝트들은 가비지 컬랙션 대상  
예를 들어 String이 + 되면서 새로운 걸 참조 할 때 이전 Strign은 버려짐 = Unreachable  
Garbage Collector가 스택의 변수를 스캔하면서 어떤걸 래퍼랜스 하는지 확인 = Mark
Mark 되어있지 않는 오브잭트 제거 = Sweep  
Marking -> Normal Deletion or Deletion with Compacting  

- Young Generation = 최초로 생성된 애들 저장, Minor GC이후 살아남으면 Old Generation으로
- Old Generation = 길게 살아남은 애들, 가득차면 Major GC 발생
- MinorGC = Young generation에서 발생하는GC
- MajorGC = old generation에서 발생하는 GC
- Full GC = Heap 메모리 전체를 Clear
- Stop the World Event = Minor GC 발생시, 모든 Application thread 중지
- Permanent Generation = 메타데이터를 저장하는 곳, Java 8 기준으로 native memory에서 관리  
  
young은 eden, S0, S1으로 분류  
생성하자 마자는 eden 여기서 minor GC가 발생하고 살아남은 애들 S0으로, age+1
다음 eden 생성 후 살아남는 애들 S1(S0에 있는 애들도)으로 S0은 싹 비움, age+1  
이 과정 반복 중 age가 일정을 넘는 애들 promotion, old로 이동

Collector 종류  
  
Serial GC  
싱글 쓰레드, java 5 & 6 default  
minor GC, major GC 순차 시행, 마이너 & 메이저 둘다 stop the world(풀 도)  
Mark-Compact collection method 사용  
  
Parallel GC  
GC 수행시 멀티 쓰레드, Default로 young generation에서만 멀티쓰레드, old는 옵션  
64비트 JVM, 멀티 CPU 유니스 Defualt, 스레드 개수 = CPU 개수  
메이저, 마이너, 풀 다 스탑더 월드  
  
Concurrent Mark Sweep (CMS) Collecter  
가비지 컬랙션 작업을 애플리케이션 스레드와 동시 수행, Stop the world 시간 최소화  
마이너는 Parallel 처럼 멀티스레드로 마이너 GC = stop-the-world 발생  
메이저는 어플리케이션 작동 중, 백그라운드로 지속적 삭제 = 메이저 stop-the-world 방지  
메모리 파편화를 위해 큰 힙싸이즈 혹은 싱글쓰레드로 old Generation 청소  

G1 Garbage Collector  
Java7 부터 사용가능, 9부터 default  
힙을 여러개의 Region으로 나눔, 일부 Region은 young generation으로, 나머지는 old로  
Young 정리는 Parallel이나 CMS로, old는 CMS처럼 백그라운드로 정리  
CMS와 달리 중간 중간을 삭제하는게 아니라 하나의 region을 통째로 정리  
사용 중인 객체는 다른 region으로 복사  
  
다형성  
하나의 객체를 여러가지 타입으로 선언 할 수 있게 하는 것  
자바에서의 다형성은 상속과 인터페이스  
  
Complie time Polymorphism (or Static polymorphsim)  
= Method Overloading  
Runtime Polymorphism (or Dynamic polymorphism)  
= Method Overriding  

String compareTo  
일반적인 compareTo는 같으면 0, A.compareTo(B) A > B는 1, A < B 는 -1  
하지만 String에서는 각각 문자의 unicode로 비교,즉 lexicographically 정렬  
비교하는 문자열의 길이가 다를 경우는 길이의 차이를 만큼 리턴  

Anonymous Class  
마치 함수 형처럼 이미 있는 클래스를 상속하거나 인터페이스를 구현해서 일회용으로 쓰는거  
익명 객체에 새롭게 정의 된 필드는 익명객체의 내부에서만 가능  

  
## 디자인 패턴

싱글톤  
인스턴스를 하나만 만들어 사용하는 패턴  
인스턴스 생성에 재약을 걸어둬야 함  

- new를 못하게 생성자를 private
- 단일 객체를 반환하게 getInstance 여기에 synchronized
- 혹은 volatile로 객체를 클래스가 로딩될떄 미리 생성하고 반환
- volatile -> 멀티스레드 환경에선 메인 메모리에서 읽은걸 캐쉬에 저장, 캐쉬를 참조 못하게 하는걸 volatile
