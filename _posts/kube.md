왜 쿠버네티스가 필요한가

운영 환경에서는 애플리케이션을 싫행하는 컨테이너를 관리하고 가동 중지 시간이 없어야한다.
컨테이너가 다운 되면 다른 컨터이너를 시작해야한다. -> 이걸 시스템화 -> 쿠버네티스

쿠버네티스는 분산 시스템을 탄력적으로 실행하기 위한 프레임 워크 제공
애플리케이션의 확장, 장애조치 처리, 배포 배턴 제공. 카나리아 배포를 쉽게 관리 할 수 있음
카나리아 배포?
오케스트레이션 = 컴퓨터 시스템과 애플리케이션, 서비스의 자동화된 설정, 관리, 조정 의미
쿠버네티스가 제공하는 것
- 서비스 디스커버리와 로드 밸런싱
    쿠버네티스는 DNS이름을 사용하거나 자체IP주소를 사용하여 컨테이너를 노출 할 수 있음.
    컨테이너에 대한 트래픽이 많으면 쿠버네티스는 네트워크 트래픽을 로드밸런싱하고 배포하여 배포가 안정적으로 이뤄질수 있음
- 스토리지 오케스트레이션
    로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재 할 수 있음
- 자동화된 롤아웃과 롤백
    쿠버네티스를 사용하여 배포된 컨테이너의 상태를 서술할 수 있음.
    현재 상태를 원하는 상태로 설정한 속도에 따라 변경 가능
    쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제거하고, 모든 리소스를 새 컨테이너에 적용 가능
- 자동화된 빈 패킹(bin packing)
    컨테이너화된 작업을 실행하는데 사용할 수 있는 쿠버네티스 클러스터 노들를 제공
    각 컨테이너가 필요로하는 CPU와 RAM을 쿠버네티스에 지시, 쿠버네티스는 컨테이너를 노드에 맞춰 리소스를 가장 잘 사용할 수 있도록 함
- 자동화된 복구
    쿠버네티스는 실패한 컨테이너를 다시 시작, 컨테이너를 교체, '사용자 정의 상태 검사'에 응답하지 않는 컨테이너를 죽임
    서비스 준비가 끝날 때까지 그 과정을 클라이언트에게 보여주지 않음
- 시크릿과 구성 관리
    암호, Oauth 토큰 및 ssh 키와 같은 중요한 정보를 저장하고 관리 할 수 있음
    컨테이너 이미지를 재구성하지 않고 스택 구성에 시크릿을 노출하지 않고 시크릿 및 애플리케이션 구성을 배포 및 업데이트 가능

쿠버네티스가 아닌 것
쿠버네티스는 전통적인 Platform as a Service(Paas)가 아님
쿠버네티스는 하드웨어 수준보다는 컨테이너 수준에서 운영, Paas가 제공하는 배포, 스케일링, 로드 밸런싱과 같은 기능을 제공.
사용자가 로깅, 모니터링 및 알림 솔루션을 통합할 수 있음
하지만 쿠버네티스는 모놀리식(monolithic)이 아니어서, 이런 기본 솔루션이 선택적이며 추가나 제거가 용이, 사용자의 선택권과 유연성을 지켜줌

쿠버네티스 컴포넌트
쿠버네티스를 배포하면 클러스터를 얻음
쿠버네티스 클러스터는 컨테이너화된 애플리케이션을 실행하는 노드라고 하는 워커 머신의 집합. 모든 큰러스터는 최소 한개의 워커 노드를 가짐
워커 노드는 애플리케이션의 구성요소인 pod를 호스트함. 
pod = 클러스터에서 실행 중인 컨테이너의 집합
컨트롤 플레인은 워커노드와 클러스터 내 파드를 관리
운영 환경에서는 일반적으로 컨트롤 플레인이 여러 컴퓨터에 걸쳐 실행됨, 클러스터는 일반적으로 여러 노드를 실행함, 내결함성과 고가용성이 제공

컨트롤 플레인 컴포넌트
컨트롤 플레인 컴포넌트는 클러스터에 관한 전반적인 결정(ex. 스케줄링)을 수행하고 
클러스터 이벤트(배포 요구 조건이 충족되지 않은면 새로운 pod를 구동하는것)을 감지 및 반응
컨트롤 플레인 컴포넌트는 클러스터 내 어떠한 머신에서든지 동작 가능
간결성을 위해, 구성 스크립트는 보통 동일 머신상에 모든 컨트롤 컴포넌트를 구동시키고, 사용자 컨테이너는 해당 머신상에 동작 시키지 않음

kube-apiserver
API 서버는 쿠버네티스 API를 노출하는 쿠버네티스 컨트롤 플레인 컴포넌트
API서버는 쿠버네티스 컨트롤 플레인의 프론트 엔드이다
쿠버네티스 API 서버의 주요 구현은 kube-apiserver. kube-apiserver는 수평으로 확장
즉, 더 많은 인스턴스를 배포해서 확장 가능, 여러 kube-apiserver인스턴스를 실행 하고, 인스턴스 간의 트래픽은 조절

etcd
key-value 저장소, 모든 클러스터 데이터를 담는 쿠버네티스 뒷단의 저장소, 백업 계획 필수

kube scheduler
노드가 배정되지 않은 새로 생성된 pod를 감지하고, 실행 할 노드를 선택하는 컨트로 플레인 컴포넌트
스케줄링 결정을 위해 고려되는 요소는
리소스에 대한 요구사항, 하드웨어/소프트웨어 정책 제약, affinity & anti-affinity 명세
데이터 지역성, 워크로드 간 간섭, 데드라인

kube-controller-manager
컨트롤러를 구동하는 마스터 상의 컴포넌트
각 컨트롤러는 개별 프로세스이지만, 복잡성을 낮추기 위해 모두 단인 바이너리로 컴파일되고 단일 프로세스 내에서 실행된다.
컨트롤러가 포함하는것
노드 컨트롤러 - 노드가 다운됐을 때 통지와 대응에 관한 책임
레플리케이션 컨트롤러 - 시스템의 모든 레플리케이션 컨트롤러 오브젝트에 대하 알맞은 파드 수를 유지 책임
앤드포인트 컨트롤러 - 앤드포인트 오브젝트를 채움(서비스와 파드를 연결)
서비스 어카운트 & 토큰 컨트롤러 = 새로운 네임스페이스에 대한 기본 계정과 API 접근 토큰을 생성

cloud-controller-manager
클라우드별 컨트롤 로직을 포함하는 쿠버네티스 컨트롤 플레인 컴포넌트
클러스터를 클라우드 공급자의 API에 연결, 해당 클라우드 플랫폼과 상호 작용하는 컴포넌트와 클러스터와 상호작용하는 컴포넌트 분리
cloud-controller-manager는 클라우드 제공자 전용 컨트롤러만 실행, 
사내 또는 PC 내부의 학습환경에서 쿠버네티스를 실행 중인 경우에는 클라우드 컨트롤러 매니저 없음
kube-controller-manager와 마찬가지로 cloud-controller-manager는 논리적으로 독립적인 여러 컨트롤 루프를 단일 프로세스로 실행하는 단일 바이너리로 결합
수평 확장 가능
클라우드 제공 사업자의 의존성을 가질 수 있음
노드 컨트롤러 - 노드가 응답을 멈춘 후 클라우드 상에서 삭제 됐는지 판별하기 위해 클라우드 제공사업자에게 확인 하는것
라우트 컨트롤러 - 기본 클라우드 인프라에 경로를 구성하는것
서비스 컨트롤러 - 글라우드 제공 사업자 로드밸런서를 생성, 업데이트, 삭제하는 것


노드 컴포넌트
노드 컴포넌트는 동작 중인 파드를 유지 시킴, 쿠버네티스 런타임 환경 제공, 모든 노드상에서 동작

kubelet
클러스터의 각 노드에서 실행되는 에이전트 
kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리
kubelet은 PodSpec의 집합을 받아 컨테이너가 해당 파드 스펙에 따라 건강하게 동작하는 것을 확실히 한다.
kubelet은 쿠버네티스를 통해 생성되지 않는 컨테이너는 관리하지 않음

kube-proxy
kube-proxy는 클러스터의 각 노드에서 실행되는 네트워크 프록시
쿠버네티스의 서비스 개념의 구현부
kube-proxy는 노드의 네트워크 규칙을 유지 관리
이 네트워크 규칙이 내부 네트워크 세션이나 클러스터 바깥에서 파드로 네트워크 통신을 할 수 있도록 함
kube-proxy는 운영 체제에 가용한 패킷 필터링 계층이 있으면 이를 사용, 없으면 트래픽 자체를 포워드

컨테이너 런타임
컨테이너 실행을 담당하는 소프트웨어, 쿠버는 여러 컨테이너 런타임을 지원. ex. docker

