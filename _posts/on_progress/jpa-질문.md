# JPA 기본 문제 정리

## ORM이란

- Object Relational Mapping
- 관계형 데이터베이스와 객체를 매핑하는 기법

## JPA란

- Java Persistence API
- Java에서의 ORM 기술을 표현하는 표준 API

## 영속성 컨텍스트

- 애플리케이션과 데이터베이스 사이에서 엔티티를 영구적으로 저장하는 환경
- persist() 통해, 엔티티를 영속성 컨택스트에 저장, 이후, flush()가 발생하면 DB에 저장됌

## 영속성 컨텍스트 장점

- 1차 캐시, 엔티티를 영속성 컨텍스트에 저장 혹은 조회 했을 때, 1차 캐시에 저장됌
  - 영속성 컨텍스트는 조회가 발생하면, 1차 캐시를 먼저 조회 이후, DB 조회
  - 스레드별 하나, 공유되지 않는 캐시
- 동일성 보장, 1차 캐시를 이용 같은 객체를 조회 할 수 있게 된다.
- 트랜잭션을 지원하는 쓰기 지연
  - 엔티티를 영속성 컨텍스트에 저장하고, SQL 저장소에 insert문을 쌓아 놓고, commit 시점에 동시 발생
  - flush를 통해 SQL을 보내고 commit, 트랜잭션 커밋 시점에 flush & commit 발생
- Dirty Checking(변경 감지)
  - 엔티티를 수정하고, 트랜잭션을 커밋하면 자동으로 업데이트 쿼리 진행
  - 1차 캐시에 저장 할 때, 스냅샷 필드도 저장, 이후 flush or commit 발생시 엔티티와 스냅샷 비교
  - 변경 사항이 있으면 Update 쿼리 진행

## 엔티티의 상태(생명주기)

- 비영속
  - 영속성 컨텍스트와 관계가 전혀 없는 상태
- 영속
  - 영속성 컨텍스트에 저장된 상태
  - 엔티티가 영속성 컨택스트에 의해 관리
  - DB에는 커밋 시점에 저장됌
- 준영속
  - 영속성 컨텍스트에 저장 되었다가 불리된 상태
- 삭제
  - 영속성 컨텍스트에서 삭제된 상태, DB에서도 삭제 당한다.

## 프록시

- 원복 엔티티를 상속 받은 프록시 객체, 실제 객체에 대한 참조를 보관
- 프록시 객체의 메소드를 호출하면, 프록시 객체는 실제 객체의 메소드를 호출 = 객체 초기화
- 프록시 객체가 초기화 되면, 프록시 객체를 통해 실제 엔티티 접근가능
- 영속성 컨텍스트에 찾는 엔티티가 있다면, 프록시가 아닌 실제 엔티티 반환
- 초기화는 최초 한번만 발생, 영속성 컨텍스트의 도움이 필요

## 지연 로딩

- 조회 하는 엔티티가 영속성 컨텍스트에 존재하지 않을 경우, 프록시 객체 반환
- 프록시 객체를 통해 실제 엔티티의 메소드를 사용할 때, 프록시 객체를 초기화하며 엔티티를 조회

## 영속성 전이 CASCADE

- 특정 엔티티를 엔티티를 영속 상태로 만들 때, 연관 엔티티도 영속 상태로 만들고 싶을때 사용

## jpa 동작 과정 - 저장

- 트랙잭션 시작 -> 객체 생성 -> 엔티티 매니저를 이용, 영속성 등록 -> 엔티티 영속 상태 -> flush를 통해 저장 -> 커밋

## jpa 동작 과정 - 수정

- 엔티티 조회 -> 객체 수정 -> flush 발생시, 1차 캐시와 비교, 변경 감지 -> 커밋

## Hibernate란

- ORM 프레임워크
- 각 데이터베이스 방언에 맞춰 SQL을 작성해줌

## Open Session In View

- 원래 영속성 컨텍스트는 트랜잭션이 끝나면 끝남
- OSIV는 트랜잭션은 서비스 레이어에서 종료, 영속성 컨택스트는 View 레이어까지 유지
- 필터 혹은 인터셉터에서 영속성 컨텍스트 생성, 트랜잭션은 아직 생성하지 않음
- 서비스 레이어에서 @Transactional로 트랜잭션을 시작할 때, 트랜잭션시작
- 서비스 계층이 끝나면, flush하고 commit 후 트랜잭션 종료, 하지만 영속성 컨택스트는 유지
- 필터 혹인 인터셉터에 반환 될때, 영속성 컨텍스트를 종료
- 트랜잭션이 없는 상태에서, Lazy-Loading 발생시, 트랜잭션 없이 진행
- 하지만 변경 감지 수정은 동작하지 않음
- DB 커낵션을 유지한 상태, 리소스 낭비가 있음

## @transactional 동작 과정

- IoC 컨테이너는 서비스의 트랜잭션 프록시도 인스턴스화
- 프록시 객체는 트랜잭션 매니저를 이용, 커넥션을 관리
- JPA에선 JpaTransactionManager 활용

## readOnly 활용

- readOnly 옵션을 줄 경우, 엔티티의 등록, 수정, 삭제가 작동하지 않음
- 또한 변경 감지가 작동 하지 않고, 영속성 컨텍스트 또한 스냅샷을 보관하지 않음

## N+1 문제

- join으로 묶여있는 엔티티 간에서, 하나의 쿼리를 수행하는 데 N개의 쿼리가 수행되는 현상
- 예를 들어, 한명의 사용자가 N개의 카드를 소유하는데, 한명의 사용자를 조회하기 위해 N개의 카드 조회 쿼리가 나가는 현상

## N+1 해결책

- join fetch 사용
  - 조회시 바로 가져오고 싶은 엔티티를 지정 join fetch card를 하는것
  - 하지만 불필요한 쿼리문 추가, 별도 조회 메소드 관리 필요, 2개 이상 조인 불가, 페이징 불가
- @EntityGraph 사용
  - 쿼리 수행시 가져올 필드명을 attributePaths에 지정하면 Eager 조회
  - 다만, Join fetch는 inner join, EntityGraph는 outer join
- BatchSize 사용
  - @BatchSize를 사용하여 조회할 데이터를 미리 로딩 where in 조회

## JPA에서 PK

- @Id
  - @GenerateValue
    - IDENTITY
      - 데이터베이스에 위임, AUTO_INCREMENT
      - persist 시점에 insert가 날라감
    - SEQUENCE
      - 데이터베이스의 Sequence Object 사용
      - SequneceGenerator 필요 
      - persist 전에 DB sequence를 가져옴
    - TABLE
      - 키생성 전용 테이블 활용
    - AUTO
- @Embeddable & @EmbeddedId;
  - @Embeddable되는 키는 Serializable 해야함
- @IdClass
  - @IdClass도 Serializable 해야함

## QueryDsl

- Query를 통해서 JPQL 작성은 문자열이라 컴파일시 에러 확인이 불가능
- 동적 쿼리에 장점
